<[DEVELOPER NOTES]> Python 3.10.6, pip 22.2.1- If an error occur, please check the requirements.txt for certain versions.
PLEASE RUN THIS COMMAND FOR ANY CHANGES IN THE CODING (Creates a new application) [pyinstaller --onefile --windowed gui.py] 
For installing the dependencies [pip install -r requirements.txt]
For activating the venv [venv\Scripts\activate]

#Project structure:
Phishing_Detector_GoogleExtension/
├── data/
│   └── phishing_dataset.csv  
├── images/
├── popup/
│   └── popup.html
│   └── styles.css
│   └── popup.js
├── app.py
├── gui.py
├── background.js
├── Blocked.html
├── content.js
├── manifest.json
                   
#Project Coding:
phishing_dataset.csv #(my custom dataset)
text,label,normalized_text
#examples real URL format
phishing_URL,1
non_phishingURL,0


popup.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phishing Detection</title>
    <!-- Get your own code at fontawesome.com -->
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet'>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="logo">
        <img src="image/icon128.png" alt="logo">
    </div>
    <h1>QUANTUM SHIELD</h1>
    <hr size="2" width="100%">
    <div class="image-container">
        <img src="image/magnifier-zoom.gif" alt="Animated GIF">
    </div>
    <p>Click a URL to monitor its status.</p>
    <p>Phishing detector:   <span id="status" class="status-border">Checking...</span></p>

    <script src="popup.js"></script>
</body>
</html>


popup.js
document.addEventListener('DOMContentLoaded', function () {
    const statusElement = document.getElementById('status');

    fetch('http://127.0.0.1:5000/status')
        .then(response => {
            if (response.ok) {
                statusElement.textContent = 'Active';
                statusElement.classList.add('active');
            } else {
                throw new Error('Server offline');
            }
        })
        .catch(error => {
            statusElement.textContent = 'Offline';
            statusElement.classList.add('offline');
        });
});


styles.css
/* styles.css */

/* General Styles */
body {
    font-family: 'Roboto';
    font-size: 22px;
    background-color: #ffffff3b;
    color: #333;
    margin: 15;
    padding: 0px;
    width: 280px;
    height: 110px;
    box-sizing: border-box;
}

/* Heading */
h1 {
    font-size: 18px; /* Larger font size */
    color: #5300ab; /* Purple color */
    text-align: left;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2); /* Add a subtle shadow */
}

/* Paragraph */
p {
    text-align: center;
    text-align: justify;
    text-justify: inter-word;
    font-size: 14px;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
}


/* Image Container */
.image-container {
    float: right; /* Align the image to the right */
    margin-left: 0px;
}

.image-container img {
    width: 60px; /* Set the desired width */
    height: auto; /* Maintain aspect ratio */
}

/* Logo */
.logo {
    float: left;
    margin-right: 7px;
}

.logo img {
    width: 22px; /* Set the desired width */
    height: auto; /* Maintain aspect ratio */
}

#status.active {
    color: rgb(0, 210, 0);
}

#status.offline {
    color: rgb(244, 65, 65);
}

/* Status Border */
.status-border {
    padding: 2px 8px;
    border-radius: 12px;
    font-weight: bold;
    display: inline-block;
    text-align: center;
    min-width: 35px;
    margin-left: 5px;
}

/* Active Status */
#status.active {
    color: white;
    background-color: rgb(0, 210, 0);
    border: 2px solid rgb(0, 210, 0);
}

/* Offline Status */
#status.offline {
    color: white;
    background-color: rgb(244, 65, 65);
    border: 2px solid rgb(244, 65, 65);
}


app.py
import pandas as pd
import requests
from flask import Flask, request, jsonify
from flask_cors import CORS
import time
import threading
from threading import Lock
phishing_data_lock = Lock()
import logging

# Set up logging
logging.basicConfig(filename='app_logs.log', level=logging.INFO, format='%(asctime)s - %(message)s')

# Example of logging a message
logging.info("Phishing detection service started.")

app = Flask(__name__)
CORS(app)

# Define dataset path and OpenPhish feed URL
DATASET_PATH = 'data/phishing_dataset.csv'
OPENPHISH_FEED_URL = 'https://openphish.com/feed.txt'

# Lock to prevent concurrent access to phishing data
phishing_data_lock = Lock()

# Load the initial phishing dataset
phishing_data = pd.read_csv(DATASET_PATH)

def normalize_url(url):
    """Normalize URL by removing trailing slashes and converting to lowercase."""
    return url.rstrip('/').lower()

def is_phishing_url(url):
    """Check if a URL is in the phishing dataset."""
    normalized_url = normalize_url(url)
    phishing_data['normalized_text'] = phishing_data['text'].apply(normalize_url)
    
    # Filter matching URLs and check if any are labeled as phishing
    matching_rows = phishing_data[phishing_data['normalized_text'] == normalized_url]
    
    if not matching_rows.empty:
        return matching_rows['label'].max()  # If mixed, treat it as phishing (label 1)
    return False

def update_phishing_dataset():
    """Fetch real-time phishing URLs from OpenPhish and update the dataset."""
    global phishing_data
    with phishing_data_lock:
        try:
            response = requests.get(OPENPHISH_FEED_URL)
            if response.status_code == 200:
                new_urls = response.text.splitlines()

                # Normalize and create new rows to add
                existing_urls = phishing_data['text'].tolist()
                new_entries = [{'text': url, 'label': 1} for url in new_urls if url not in existing_urls]
                new_urls = [normalize_url(url) for url in response.text.splitlines()]

                if new_entries:
                    # Create a new DataFrame and concatenate it with the existing data
                    new_df = pd.DataFrame(new_entries)
                    phishing_data = pd.concat([phishing_data, new_df], ignore_index=True)

                    # Save updated phishing data to CSV
                    phishing_data.to_csv(DATASET_PATH, index=False)
                    message = f"Added {len(new_entries)} new phishing URLs from OpenPhish."
                    
                else:
                    logging.info("No new phishing URLs to add.")
                    message = "No new phishing URLs to add."
            else:
                logging.error(f"Failed to fetch OpenPhish data. Status code: {response.status_code}")
                message = f"Failed to fetch OpenPhish data. Status code: {response.status_code}"
        except Exception as e:
            logging.error(f"Error fetching OpenPhish data: {str(e)}")
            message = f"Error fetching OpenPhish data: {str(e)}"
    
    # Log the message to a file that can be read by the GUI
    with open("phishing_log.txt", "a") as log_file:
        log_file.write(message + "\n")
    
    return message   

def schedule_dataset_update():
    """Continuously update the dataset every 60 minutes."""
    while True:
        update_phishing_dataset()
        time.sleep(3600)  # Update every hour

# Background thread to update the phishing dataset
threading.Thread(target=schedule_dataset_update, daemon=True).start()

@app.route('/status', methods=['GET'])
def status():
    return jsonify({"status": "active"}), 200

@app.route('/analyze', methods=['POST'])
def analyze_url():
    data = request.get_json()
    url = data.get('url')
    if not url:
        return jsonify({"error": "No URL provided"}), 400

    # Detect phishing using the real-time dataset
    is_phishing = bool(is_phishing_url(url))  # Convert NumPy bool_ to Python bool
    
    # Return the result to the extension
    return jsonify({"url": url, "is_phishing": is_phishing})

if __name__ == '__main__':
    app.run(debug=True)


gui.py
import sys
import subprocess
import os
import signal
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QVBoxLayout, QLabel, QPushButton, QTabWidget, QTextEdit, QSpacerItem, QSizePolicy
from PyQt5.QtGui import QFont, QIcon, QTextCursor
from PyQt5.QtCore import Qt, QTimer
import requests
import pandas as pd

class QuantumShieldGUI(QWidget):
    def __init__(self):
        super().__init__()

        # Initialize Matplotlib Figure and Canvas
        self.figure = Figure()
        self.canvas = FigureCanvasQTAgg(self.figure)

        # Window Setup
        self.setWindowTitle('Quantum Shield')
        self.setWindowIcon(QIcon('images/icon48.png'))  # Logo for the app
        self.setGeometry(1000, 600, 400, 300)  # Window size

        # Custom Font and Project Title (Phishing Detector)
        self.setStyleSheet("background-color: #e7e4f9;")  # Slightly brighter background

        # Header Title "Phishing Detector"
        self.title_label = QLabel('Phishing Detector', self)
        self.title_label.setFont(QFont('Roboto', 24))
        self.title_label.setAlignment(Qt.AlignCenter)
        self.title_label.setStyleSheet('color: #5300ab; padding: 20px;')  # Purple color, tech look

        # Circular Activate/Deactivate Button
        self.toggle_button = QPushButton('Activate', self)
        self.toggle_button.setFont(QFont('Roboto', 14))
        self.toggle_button.setFixedSize(150, 150)  # Ensure fixed size for circular button
        self.toggle_button.setStyleSheet('''
            QPushButton {
                background-color: green;
                color: white;
                font-size: 18px;
                border-radius: 75px;  /* Make the button circular */
            }
            QPushButton:hover {
                background-color: #00cc00;  /* Lighter green when hovered */
            }
            QPushButton:pressed {
                background-color: #006400;
            }
        ''')
        self.toggle_button.clicked.connect(self.toggle_app)

        # Status Indicator - Active/Inactive after the button, aligned left
        self.status_label = QLabel('⦿ Inactive', self)
        self.status_label.setFont(QFont('Roboto', 16))
        self.status_label.setStyleSheet('color: red')  # Default to red for inactive
        self.status_label.setAlignment(Qt.AlignLeft)

        # Shield Activity Button
        self.stats_button = QPushButton('Shield Activity', self)
        self.stats_button.setFont(QFont('Roboto', 11))
        self.stats_button.setFixedSize(120, 40)
        self.stats_button.setStyleSheet('''
            QPushButton {
                border: 2px solid #2e2c9a;  /* Info-colored border */
                border-radius: 8px;  /* Rounded corners */
                background-color: transparent;  /* Transparent background */
                color: #2e2c9a;  /* Info-colored text */
                padding: 5px;
    }
    QPushButton:hover {
        background-color: rgba(46, 44, 154, 0.1);  /* Light transparent background on hover */
        color: #3a2081;  /* Brighter color for text on hover */
        border: 2px solid #3a2081;  /* Brighter border on hover */
    }
    QPushButton:pressed {
        background-color: rgba(46, 44, 154, 0.2);  /* Slightly darker transparent background when pressed */
        color: #120348;  /* Change text color to white when pressed */
        border: 2px solid #120348;  /* Keep border the same brighter color */
    }
        ''')
        self.stats_button.clicked.connect(self.open_stats_window)

        # Layout Setup
        layout = QVBoxLayout()
        layout.addWidget(self.title_label)  # Phishing Detector Title
        layout.addWidget(self.toggle_button, alignment=Qt.AlignCenter)  # Center the circular button
        layout.addWidget(self.status_label, alignment=Qt.AlignLeft)  # Align the status to the left
        layout.addWidget(self.stats_button, alignment=Qt.AlignLeft)  # Center the Shield Activity button
        self.setLayout(layout)

        # Move to bottom right of the screen
        self.move_to_bottom_right()

        # To track if app.py is running
        self.is_active = False
        self.app_process = None  # To store the process of app.py

        # Check the current status of app.py on startup
        self.check_app_status()

    def move_to_bottom_right(self):
        screen_geometry = QApplication.primaryScreen().availableGeometry()
        screen_size = screen_geometry.size()
        window_size = self.size()

        # Adjust X to keep it in the right corner
        x = screen_size.width() - window_size.width() - 7

        # Adjust Y to move the window up a little from the bottom corner
        y = screen_size.height() - window_size.height() - 70  # Adjust as needed

        self.move(x, y)

    def toggle_app(self):
        # Toggle between active/inactive states
        if not self.is_active:
            self.activate_app()
        else:
            self.deactivate_app()

    def activate_app(self):
        # Check if app.py is already running by querying the status endpoint
        try:
            response = requests.get('http://127.0.0.1:5000/status')
            if response.status_code == 200:
                print("App is already running")
                self.is_active = True
                self.update_ui_active()
                return  # App is already active, no need to restart

        except Exception:
            print("starting app.py...")

        # If app.py is not running, start it
        try:
            if sys.platform == "win32":
                self.app_process = subprocess.Popen(
                    ['python', 'app.py'],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    creationflags=subprocess.CREATE_NO_WINDOW  # Suppress the Command Prompt window
                )
            else:
                self.app_process = subprocess.Popen(
                    ['python3', 'app.py'],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    preexec_fn=os.setsid  # For Unix-like systems to allow termination
                )
            self.is_active = True
            self.update_gui_state()

        except Exception as e:
            print(f"Error starting app.py: {e}")
            self.is_active = False

    def deactivate_app(self):
        # Terminate the process if app.py is running
        if self.app_process and self.app_process.poll() is None:
            print("Stopping app.py...")
            try:
                # Use os.kill with SIGTERM for cross-platform compatibility
                if os.name == 'nt':  # For Windows
                    subprocess.call(['taskkill', '/F', '/T', '/PID', str(self.app_process.pid)])
                else:  # For Unix/Linux systems
                    os.killpg(os.getpgid(self.app_process.pid), signal.SIGTERM)
                self.app_process.wait()  # Ensure it's terminated
            except Exception as e:
                print(f"Error while stopping app.py: {e}")
            finally:
                self.is_active = False
                self.update_gui_state()
        else:
            print("No app.py process found to stop.")

    def check_app_status(self):
        # Check if app.py is running on startup
        try:
            response = requests.get('http://127.0.0.1:5000/status')
            if response.status_code == 200:
                self.is_active = True
                self.update_gui_state()
            else:
                self.is_active = False
                self.update_gui_state()
        except:
            self.is_active = False
            self.update_gui_state()

    def update_gui_state(self):
        # Update button and status label based on whether app.py is active
        if self.is_active:
            self.toggle_button.setText('Deactivate')
            self.toggle_button.setStyleSheet('''
                QPushButton {
                    background-color: #e2160f;
                    color: white;
                    font-size: 18px;
                    border-radius: 75px;
                    border: 4px solid #bb120c;
                }
                QPushButton:hover {
                    background-color: #fd3a36;  /* Lighter red when hovered */
                }
                QPushButton:pressed {
                    background-color: #8B0000;
                }
            ''')
            self.status_label.setText('⦿ Active')
            self.status_label.setStyleSheet('color: green')
        else:
            self.toggle_button.setText('Activate')
            self.toggle_button.setStyleSheet('''
                QPushButton {
                    background-color: #3a2081;
                    color: white;
                    font-size: 18px;
                    border-radius: 75px;                        
                    border: 4px solid #2e2c9a;
                }
                QPushButton:hover {
                    background-color: #4d2bab;
                }                             
                QPushButton:pressed {
                    background-color: #3a2081;
                }
            ''')
            self.status_label.setText('⦿ Inactive')
            self.status_label.setStyleSheet('color: red')

    def open_stats_window(self):
        # Create a new window to display Shield Activity
        self.stats_window = QWidget()
        self.stats_window.setWindowTitle('Shield Activity')
        self.stats_window.setWindowIcon(QIcon('images/icon48.png'))
        
        # Create a QTabWidget to hold tabs
        tab_widget = QTabWidget()

        # Create the dataset tab with a better layout
        self.dataset_tab = QWidget()
        dataset_layout = QVBoxLayout()
        # Add a header label for the dataset
        header_label = QLabel("Phishing Dataset Statistics")
        header_label.setStyleSheet("font-weight: bold; font-size: 16px; margin-bottom: 6px;")  # Customize the style as needed
        dataset_layout.addWidget(header_label)
        # Create a label to show the phishing URL count
        self.dataset_info_label = QLabel("")
        self.dataset_info_label.setStyleSheet("font-size: 14px;")  # Customize the style as needed
        dataset_layout.addWidget(self.dataset_info_label)

        # Add the Matplotlib canvas to the layout for the graphs
        self.canvas = FigureCanvasQTAgg(self.figure)
        self.canvas.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        dataset_layout.addWidget(self.canvas)

        self.dataset_tab.setLayout(dataset_layout)

        # Create the Logs tab
        self.logs_tab = QWidget()
        logs_layout = QVBoxLayout()
        self.logs_area = QTextEdit(self.logs_tab)
        self.logs_area.setReadOnly(True)
        logs_layout.addWidget(self.logs_area)
        self.logs_tab.setLayout(logs_layout)

        # Add tabs to the QTabWidget
        tab_widget.addTab(self.dataset_tab, "Phishing Dataset")
        tab_widget.addTab(self.logs_tab, "Logs")

        # Layout for the Shield Activity window
        stats_layout = QVBoxLayout()
        stats_layout.addWidget(tab_widget)
        self.stats_window.setLayout(stats_layout)
        self.stats_window.resize(535, 335)

        # Get the position of the main window
        main_window_geometry = self.geometry()

        # Set the Shield Activity window to open beside the main window (to the left)
        stats_x = main_window_geometry.x() - self.stats_window.width() - 10  # 10 pixels of spacing to the left
        stats_y = main_window_geometry.y() - self.stats_window.height() + 303

        # Move the stats window to the left of the main window
        self.stats_window.move(stats_x, stats_y)

        # Start a timer to update logs every second in real-time
        self.log_timer = QTimer(self)
        self.log_timer.timeout.connect(self.update_log)
        self.log_timer.start(1000)  # Update every second

        # Load the phishing dataset and display statistics
        self.update_dataset_stats()

        # Show the stats window
        self.stats_window.show()

    def update_log(self):
        # Update the logs in the stats window in real-time, showing new logs at the top
        log_file = 'app_logs.log'
        try:
            # Open the log file and read all lines
            with open(log_file, 'r') as f:
                logs = f.readlines()

            # If the file contains more than 200 lines, overwrite the file to keep only the last 200 lines
            if len(logs) > 200:
                with open(log_file, 'w') as f:
                    f.writelines(logs[-200:])

            # Read only the last 50 lines to display
            logs_to_display = logs[-50:]
            self.logs_area.setPlainText("".join(logs_to_display))
            self.logs_area.moveCursor(QTextCursor.End)
        except FileNotFoundError:
            self.logs_area.setPlainText("No logs available.")
    
    def update_dataset_stats(self):
        # Load the phishing dataset CSV file
        try:
            dataset_path = 'data/phishing_dataset.csv'
            df = pd.read_csv(dataset_path)

            # Count the number of phishing URLs (where label is 1)
            phishing_count = df[df['label'] == 1].shape[0]
            # Display the number of phishing URLs captured
            dataset_info = f" {phishing_count} Phishing URLs have been captured."
            self.dataset_info_label.setText(dataset_info)

            # Clear the previous figure to avoid overlapping
            self.figure.clear()

            # Generate the bar chart for the most common domains
            ax2 = self.figure.add_subplot(111)
            df['domain'] = df['text'].apply(lambda x: x.split('/')[2] if '//' in x else x.split('/')[0])  # Extract domain
            domain_counts = df['domain'].value_counts().head(10)
            ax2.bar(domain_counts.index, domain_counts.values, color='red')

            # Set x-ticks and labels
            ax2.set_title('Top 10 Phishing Domains', fontsize=10)
            ax2.set_ylabel('Count', fontsize=10)
            ax2.set_xticks(range(len(domain_counts.index)))  # Set the tick positions
            ax2.set_xticklabels(domain_counts.index, rotation=25, ha='right', fontsize=8.5)  # Set the tick labels

            self.canvas.draw()  # Draw the new figure

        except Exception as e:
            # In case of any error, display it in the dataset area
            self.dataset_info_label.setText(f"Error loading dataset: {str(e)}")

    def closeEvent(self, event):
        # Ensure app.py is properly terminated if the GUI is closed
        if self.is_active:
            self.deactivate_app()
        event.accept()  # Close the window

if __name__ == '__main__':
    app = QApplication(sys.argv)
    quantum_shield_gui = QuantumShieldGUI()
    quantum_shield_gui.show()
    sys.exit(app.exec_())


background.js
function checkForPhishing() {
    if (typeof chrome.tabs !== 'undefined' && chrome.tabs.query) {
        chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
            let activeTab = tabs[0];
            
            // Ensure the active tab has a valid URL
            if (activeTab && activeTab.url && 
                !activeTab.url.startsWith('chrome://') && 
                !activeTab.url.startsWith('about:') && 
                !activeTab.url.startsWith('chrome-extension://')) {
                
                chrome.tabs.sendMessage(activeTab.id, {"message": "check_url"});
            } else {
                console.log("Invalid URL, skipping phishing check:", activeTab ? activeTab.url : "No active tab");
            }
        });
    } else {
        console.log("checkForPhishing function is being executed in an incorrect context.");
    }
}

// Add a health-check mechanism to keep the extension alive
function keepAlive() {
    chrome.runtime.sendMessage({check: "active"}, function(response) {
        if (!response || response.status !== "active") {
            console.log("Extension appears inactive, reactivating...");
            checkForPhishing(); // Reinitialize phishing check or any other required logic
        }
    });
}

// Set the interval in seconds
const shortInterval = 25; // seconds

// Set up periodic checks using alarms API (for Manifest v3)
chrome.alarms.create('keepAlive', { periodInMinutes: 1 });

// Listen for the alarm to recheck the extension state
chrome.alarms.onAlarm.addListener(alarm => {
    if (alarm.name === 'keepAlive') {
        console.log("Running keepAlive check...");
        keepAlive(); // Run the health check
    }
});

// Use setInterval to run keepAlive every 45 seconds
setInterval(() => {
    console.log("Running keepAlive check...");
    keepAlive(); // Run the keep-alive check
}, shortInterval * 1000); // Convert to milliseconds

// Attach listeners to the correct events
chrome.runtime.onStartup.addListener(() => {
    console.log("Extension started up");
});

chrome.runtime.onInstalled.addListener(() => {
    console.log("Extension installed");
});

chrome.tabs.onActivated.addListener(activeInfo => {
    chrome.tabs.get(activeInfo.tabId, function(tab) {
        if (tab.url && !tab.url.startsWith('chrome://') && !tab.url.startsWith('about:')) {
            checkForPhishing();  // Execute the function directly
        }
    });
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete' && tab.url && !tab.url.startsWith('chrome://') && !tab.url.startsWith('about:')) {
        checkForPhishing();  // Execute the function directly
    }
});


Blocked.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocked Page</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self';">
</head>
<body>
    <h1>Access Blocked</h1>
    <p>This page has been blocked due to phishing concerns.</p>
</body>
</html>


content.js
chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    if (request.message === "check_url") {
        let url = window.location.href;

        fetch('http://127.0.0.1:5000/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({url: url})
        })

        .then(response => response.json())
        .then(data => {
            if (data.is_phishing) {
                window.stop();  // Immediately stop navigation
                let userResponse = confirm(`WARNING: This URL has the potential to be phishing! Are you sure you want to visit ${url}?`);
                
                if (!userResponse) {
                    // If the user chooses "No", stay on the current page without further alerts.
                    alert("THIS IS A PHISHING URL! Navigation has been stopped.");
                    window.location.href = chrome.runtime.getURL('Blocked.html');


                } else {
                 // If the user chooses "Yes", do nothing and allow the user to navigate manually.
                 console.log("User chose to proceed to the phishing URL.");
                    
                }
            } else {
                console.log("This URL is safe.");
            }
        })
        .catch(error => {
            console.error(`Error checking URL ${url}:`, error);
        });
        console.log("Phishing check triggered.");
        sendResponse({status: "received"});
    }else {
        sendResponse({status: "unknown request"});
    }
});



manifest.json
{
  "manifest_version": 3,
  "name": "QUANTUM SHIELD",
  "version": "1.0",
  "permissions": [
    "activeTab",
    "webNavigation",
    "scripting",
    "storage",
    "tabs",
    "alarms"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"]
    }
  ],
  "action": {
    "default_popup": "popup/popup.html",
    "default_icon": {
      "16": "images/icon16.png",
      "48": "images/icon48.png",
      "128": "images/icon128.png"
    }
  },
  "icons": {
    "16": "images/icon16.png",
    "48": "images/icon48.png",
    "128": "images/icon128.png"
  },
  "host_permissions": [
    "<all_urls>"
  ],
  "web_accessible_resources": [
    {
      "resources": ["popup/popup.js", "Blocked.html"],
      "matches": ["<all_urls>"]
    }
  ]
}

IDEAS FOR FURTHER IMPROVEMENT

Ideas:

★ Adding a function where we can add dataset in the Shield Activity interface as a new tab

The problem is:

Target to achieve:
